
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Learn Prolog The Hard Way</title>
  <meta name="author" content="泰安小码农">

  
  <meta name="description" content="家谱 假设我们有这样一个家谱图： 我们现在的任务是将这个家谱图写成程序代码的形式。请打开你最喜欢的文本编辑器，输入以下代码。 male(di).
male(jianbo).
female(xin).
female(yuan).
female(yuqing).
father(jianbo,di). &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fengdidi.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Learn Prolog The Hard Way" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Learn Prolog The Hard Way</a></h1>
  
    <h2>笨办法学Prolog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fengdidi.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/16/di-2zhang-shui-shi-shui-de-ba-ba/">第2章:谁是谁的爸爸</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-16T20:57:00+01:00" pubdate data-updated="true">Nov 16<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>家谱</h2>

<p>假设我们有这样一个家谱图：</p>

<p><img src="/images/chapter2_1.png" title="family-tree" alt="&quot;alt&quot;" /></p>

<p>我们现在的任务是将这个家谱图写成程序代码的形式。请打开你最喜欢的文本编辑器，输入以下代码。</p>

<pre><code>male(di).
male(jianbo).
female(xin).
female(yuan).
female(yuqing).
father(jianbo,di).
father(di,yuqing).
mother(xin,di).
mother(yuan,yuqing).
grandfather(X,Y):-father(X,Z),father(Z,Y).
grandmother(X,Y):-mother(X,Z),father(Z,Y).
daughter(X,Y):-father(X,Y),female(Y).
</code></pre>

<p>这段代码里面的每一行都代表一个子句(clause)。其中带有“:-”的子句叫做规则(rule)，不带有&#8221;:-&#8220;的子句叫做事实(fact)。另外，在Prolog里面诸如&#8221;di&#8221;和&#8221;jianbo&#8221;这类以小写英文字母开头的名称我们称它们为原子(atom)，以大写英文字母为开头的名称我们称它们为变量，例如上面程序里面的&#8221;X&#8221;和&#8221;Y&#8221;。顾名思义，原子是常量，即它的值是不可变的，而变量的值可以改变。最后需要讲的是，在Prolog里面&#8221;,&#8221;代表逻辑关系中的&#8221;且&#8221;，我们回在后面的章节里面看到，&#8221;;&#8221;代表逻辑关系里面的&#8221;或&#8221;。</p>

<p>已经被这些名称搞得头晕了？没关系，我会在之后的教程里面详细的介绍Prolog的数据类型和术语，在这里，你只需有初步的了解即可。</p>

<p>保存上述代码到你的磁盘的某个地方，例如在Mac系统里，我把它存到“～/prolog/chapter2.pl”,然后依照第一章里面讲的那样，进入SWI-Prolog。在SWI-Prolog里面输入如下查询：</p>

<pre><code>?- consult('path/to/your/chapter2.pl').
</code></pre>

<p>在我的电脑里，我应该这么输入：</p>

<pre><code>?- consult('~/prolog/chapter2.pl').
</code></pre>

<p>这里&#8221;consult&#8221;的意思是让SWI-Prolog加载你编写的程序，然后编译它。输入完这句查询以后，敲击回车键，你应该得到如下输出：</p>

<pre><code>% /Users/fengdi/prolog/chapter2.pl compiled 0.00 sec, 3,816 bytes
true.
</code></pre>

<p>如果你得到了上述的输出，那么恭喜你，你的第一个程序完成了。如果你得到的是其他的错误的输出，请重新检查你的程序代码是否输入正确(不过要记得，千万不要因为想要保证代码输入的不出错而直接复制粘贴代码，那样的话你学不到真正的东西)。下面，让我们考验一下我们的SWI-Prolog现在都知道些什么。在SWI-Prolog里面输入下面一个查询：</p>

<pre><code>grandfather(X,yuqing).
</code></pre>

<p>令人惊讶的事情发生了！你得到了下列输出：</p>

<pre><code>X = jianbo.
</code></pre>

<p>你的电脑告诉你，&#8221;yuqing&#8221;的祖父是&#8221;jianbo&#8221;。现在请看之前我们编写的&#8221;chapter2.pl&#8221;程序代码，我们在程序里根本没有明确的说明谁是谁的祖父，我们只是给了一个规则：</p>

<pre><code>grandfather(X,Y):-father(X,Z),father(Z,Y).
</code></pre>

<p>我们说，当X是Z的父亲并且Z是Y的父亲的时候，X是Y的祖父。然后我们问，yuqing的祖父是谁，Prolog就能自动帮我们找到答案！</p>

<p>下面再看一个例子：</p>

<pre><code>parent(keyuan,jianbo).
parent(jianbo,di).
parent(di,yuqing).

ancestor(X,Y):-parent(X,Y).
ancestor(X,Y):-parent(X,Z),ancestor(Z,Y).
</code></pre>

<p>在这个例子里面，我们定义了一个回溯的规则&#8221;ancestor&#8221;，规则可以这样解读：我们可以说X是Y的祖先基于两个条件：X是Y的parent，或者存在一个Z，使得X是Z的parent并且Z是Y的祖先。请读者仔细的想一下，是不是这个道理呢？为了证明我们的程序的正确性，我们输入一下查询：</p>

<pre><code>?- ancestor(keyuan,yuqing).
</code></pre>

<p>Prolog会返回：</p>

<pre><code>true.
</code></pre>

<p>这证明了我们的程序是正确的，因为根据常识，keyuan是yuqing的曾祖父，所以keyuan是yuqing的祖先。</p>

<p>好了，今天的新内容就讲到这里，下面是一个习题，你可以自己试验一下。</p>

<h2>加分习题</h2>

<ol>
<li>试着用Prolog描述一下你的家谱，并且做一些简单的查询。(小提示：在编写你的家谱的时候，你可以试着用一些新的事实，比如:&#8221;sister(your_sister,you)&#8221;&#8220;brother(your_brother,you)&#8221;等等）</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/">第1章:配置开发环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-15T20:08:00+01:00" pubdate data-updated="true">Nov 15<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这道习题几乎没有代码内容，它的主要目的是让你在计算机上安装好Prolog。你应该尽量照着说明进行操作。</p>

<h2>安装SWI-Prolog</h2>

<h3>MacOS</h3>

<ol>
<li>找一个你最喜欢的文本编辑器。在Mac系统下，TextMate也许是最好的选择，但是它是需要花钱购买的，如果你不想买的话，可以使用一些免费的文本编辑器比如Kod。需要注意的是，这写编辑器本身都是不支持Prolog代码高亮的，如果你想要这个功能，你需要下载针对这些文本编辑器的插件，其中TextMate的插件可以在这里下载到<a href="http://netcetera.org/cgi-bin/tmbundles.cgi" title="Title">TextMate Bundle</a></li>
<li>下载<a href="http://www.swi-prolog.org/download/stable" title="Title">SWI-Prolog</a>，请选择适合你系统版本的链接。下载解压之后双击安装包，等待一段时间以后，你的Prolog就安装好了。SWI-Prolog是Prolog的一个实现，作者是来自阿姆斯特丹大学的Jan，之所以选择这个Prolog实现作为开发的环境，一个原因是因为它很稳定，运行速度也算是可以，更重要的原因是它的开发文档写的很详细。这个Prolog的实现不是功能最多的，但是我个人认为是最好用的，也是最适合Prolog的初学者使用。</li>
<li>当你安装好Prolog以后，进入命令终端，输入：<pre><code>swipl</code></pre>你应当看见下图：
<img src="/images/chapter1_1.png" title="title" alt="&quot;alt&quot;" /></li>
</ol>


<h3>Windows</h3>

<ol>
<li>第一步同样是找一个自己喜欢的文本编辑器，个人推荐Notepad++，你可以轻易的在Google上搜寻到下载地址。</li>
<li>下载<a href="http://www.swi-prolog.org/download/stable" title="Title">SWI-Prolog</a>，选择Windows的安装包，下载解压之后双击安装包，等待一段时间以后，你的Prolog就安装好了。</li>
<li>与MacOS不同的是，在Windows下，你可以不必去命令行下面输入&#8221;swipl&#8221;,你可以直接双击桌面上的快捷方式就可以打开SWI-Prolog了。打开以后的界面应该和MacOS下的界面类似。</li>
</ol>


<h3>Linux</h3>

<p>我相信使用Linux系统的朋友应该都懂得如何安装一个小小的软件吧？所以在这里就不赘述了～</p>

<h2>Hello World!</h2>

<p>好像在大部分的程序语言的时候，第一个要编写的程序都是“Hello World!”。虽然“Hello World”程序不能显示出Prolog的特性，我在这里也姑且做一个“Hello World!”的程序吧，目的是让大家试一下你们刚才下载的SWI-Prolog是否工作。</p>

<p>按照之前的方法进入SWI-Prolog，在命令行下输入：</p>

<pre><code>writeln('Hello World!').
</code></pre>

<p>需要注意的是，这行代码一定要以英文中的句号&#8221;.&#8221;来结尾，Prolog中的“.”和C语言中的“;”一样，都是代表一段代码的结尾。再者，Hello World!字符串一定要以单引号来包裹。
如果输入正确的话，你将看到如下输出：</p>

<pre><code>Hello World!
true.
</code></pre>

<p>这里的“Hello World!”很好理解，这是我们要求程序输出的，那么那个奇怪的“true”是哪里来的呢？请注意，在Prolog终端输入的时候，没一个语句都是以“?-”这样两个字符开头的，它代表我们输入的程序代码其实是对Prolog系统的一个查询（问询），一旦用户输入了查询，Prolog系统会运用它的知识库来判定这个查询是真(true)是假(false). writeln是Prolog系统自己定义的一个语句, 它的作用是向当前的显示设备输出一个字符串并且换行, 所以很显然, 这个语句是真的, 因为Prolog知道有这个语句. 这就是为什么程序的最后有一个&#8221;true&#8221;. 有意思的是,因为整个过程中Prolog都是在试图证明这个语句是真是假, 向屏幕输出&#8221;Hello World!&#8221;这件事实际上是执行这个语句的&#8221;副作用&#8221;(side effect)!在Prolog中, 很多任务都是靠副作用来实现的, 包括输入输出, 甚至是参数的传递.</p>

<p>最后，如果想要退出SWI-Prolog，输入：</p>

<pre><code>halt.
</code></pre>

<p>同样，不要忘记最后的“.”～</p>

<p>好了, 到这里, 这一章就算是结束, 因为这一章讲的内容很基本, 我就不提供习题了. 下一章我们将正式开始学习有关Prolog语言的知识! 敬请期待!</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/15/di-0zhang-wei-shi-yao-yao-xue-xi-prolog/">第0章:为什么要学习Prolog</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-15T19:33:00+01:00" pubdate data-updated="true">Nov 15<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>为什么要学习Prolog</h2>

<p>当我在大学的课程表里面发现Prolog这门课的时候，我十分惊讶，我在想：为什么我要学习Prolog呢？我会使用Java, C++和php编程，这些语言已经强大到几乎可以实现任何功能，而且有很多很多写好的函数库来供你使用，为什么我还要学习什么Prolog？</p>

<p>当我开始学Prolog的时候，我发现这个语言的语法真是太奇怪了，有别于一般的编程语言，Prolog的程式是基于谓词逻辑的理论。最基本的写法是定立物件与物件之间的关系，之后可以用询问目标的方式来查询各种物件之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。但是当我真正了解Prolog的时候，才发现，正因为Prolog的这种特性才让他异常的强大，简单的说，它是一个会自己思考的语言，它可以通过搜索自己的知识库来找到问题的答案，这是其他的程序语言所做不到的。在这里，我无法过多的解释Prolog的强大之处，我相信通过一段时间的学习，你可以逐渐发现Prolog是一门值得学习的语言。你可能在将来的软件开发事业中使用不到Prolog，但是你有关Prolog的知识能够帮助你更好的使用其他的语言。</p>

<h2>Prolog的用途</h2>

<p>目前来说，Prolog主要用在人工智能和计算机语言的研究领域。Prolog和LISP是两个主要的研究人工智能算法的工具，一个有趣的现象是：在美国，研究者们喜欢用LISP，在欧洲，研究者们更倾向与使用Prolog进行开发。这两门语言没有谁好谁坏之分，个人喜好罢了，事实上，在Prolog下面可以非常简单地实现一个LISP解析器，同样的，在LISP下也可以轻易的实现一个Prolog解析器。在后面的章节里面，我和台北小码农会教大家怎么做。</p>

<p>其次，得益于Prolog的模式匹配功能，Prolog非常适合快速的开发一个语言的解析器，这使得很多计算机科学家在开发新的程序语言时，喜欢用Prolog先写一个实现，然后观察大众的反应，如何大众认为这个语言很好，就用更快的语言如C++来重新写解释器，如果大众的反应不好，就再用Prolog进行修改。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/15/qian-yan/">前言</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-15T15:47:00+01:00" pubdate data-updated="true">Nov 15<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我一直以来想写一部帮助想学Prolog的朋友学习Prolog的教程，因为我在学习Prolog的过程中，发现有关Prolog的教学文档很少很少，中文的文档更是几乎没有。这给我学习Prolog带来很大的困难，基本上都是在一边摸索一边学习的。所以我幻想着有一天能够写一篇Prolog的入门教程，来帮助其他想学Prolog的朋友对其有一个初步的了解。
这个想法在我心里存在了很久了，但是一直却没有付诸实施。其原因一是我没有太多的时间写这些文章，二是我没有一个如何写这部教程的点子。</p>

<p>直到台北小码农同学给我推荐了一个系列的教程叫《Learn XXX The Hard Way》，并且邀请我一起来仿照着写Prolog和Scheme的教程。我大致的阅读了一下《Learn Python The Hard Way》,发现那本书很适合对计算机了解不多，没有学过编程，但对编程感兴趣的朋友学习使用。那本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲到完整项目的实现。也许读完那本书并不意味着读者已经学会了编程，但至少读者会对编程语言以及编程这个行业有一个初步的了解。所以，我决定接受台北小码农的提议，仿照着这种格式来写一篇关于Prolog的入门教程。</p>

<p>这部教程假设读者有一定的英文基础，却不需要读者有半点的编程基础，反而，之前有过编程基础的朋友反而会发现学习起来有一定的吃力，因为Prolog的思考方式和其他的程序语言完全不同，所以你在写程序的时候需要时时刻刻地转换你的思维。</p>

<p>这部教程的目的是教会你编程新手所需的三种最重要的技能：读和写、注重细节、发现不同。</p>

<h2>读和写</h2>

<p>很显然，如果你连打字都成问题的话，那你学习编程也会成问题。尤其如果你连程序源代码中的那些奇怪字符都打不出来的话，就根本别提编程了。没有这样基本技能的话，你将连最基本的软件工作原理都难以学会。</p>

<p>为了让你记住各种符号的名字并对它们熟悉起来，你需要将代码写下来并且运行起来。这个过程也会让你对编程语言更加熟悉。</p>

<h2>注重细节</h2>

<p>区分好程序员和差程序员的最重要的一个技能就是对于细节的注重程度。事实上这是任何行业区分好坏的标准。如果缺乏对于工作的每一个微小细节的注意，你的工作成果将缺乏重要的元素。以编程来讲，这样你得到的结果只能是毛病多多难以使用的软件。</p>

<p>通过将这部教程里的每一个例子一字不差地打出来，你将通过实践训练自己，让自己集中精力到你作品的细节上面。</p>

<h2>发现不同</h2>

<p>程序员长年累月的工作会培养出一个重要技能，那就是对于不同点的区分能力。有经验的程序员拿着两份仅有细微不同的程序，可以立即指出里边的不同点来。程序员甚至造出工具来让这件事更加容易，不过我们不会用到这些工具。你要先用笨办法训练自己，等你具备一些相关能力的时候才可以使用这些工具。</p>

<p>在你做这些练习并且打字进去的时候，你一定会写错东西。这是不可避免的，即使有经验的程序员也会偶尔写错。你的任务是把自己写的东西和要求的正确答案对比，把所有的不同点都修正过来。这样的过程可以让你对于程序里的错误和 bug 更加敏感。</p>

<h2>不要复制粘贴</h2>

<p>你必须手动将每个练习打出来。复制粘贴会让这些练习变得毫无意义。这些习题的目的是训练你的双手和大脑思维，让你有能力读代码、写代码、观察代码。如果你复制粘贴的话，那你就是在欺骗自己，而且这些练习的效果也将大打折扣。</p>

<p>在你通过这部教程学习编程的过程中要记住一点，就是所谓的“万事开头难”，对于有价值的事情尤其如此。也许你是一个害怕失败的人，一碰到困难就想放弃。也许你是一个缺乏自律的人，一碰到“无聊”的事情就不想上手。也许因为有人夸你“有天分”而让你自视甚高，不愿意做这些看上去很笨拙的事情，怕有负你”神童”的称号。也许你太过激进，把自己跟有20多年经验的编程老手相比，让自己失去了信心。</p>

<p>不管是什么原因，你一定要坚持下去。如果你碰到做不出来的加分习题，或者碰到一节看不懂的习题，你可以暂时跳过去，过一阵子回来再看。只要坚持下去，你总会弄懂的。</p>

<p>一开始你可能什么都看不懂。这会让你感觉很不舒服，就像学习人类的自然语言一样。你会发现很难记住一些单词和特殊符号的用法，而且会经常感到很迷茫，直到有一天，忽然一下子你会觉得豁然开朗，以前不明白的东西忽然就明白了。如果你坚持练习下去，坚持去上下求索，你最终会学会这些东西的。也许你不会成为一个编程大师，但你至少会明白程序是怎么工作的。</p>

<p>如果你放弃的话，你会失去达到这个程度的机会。你会在第一次碰到不明白的东西时(几乎是所有的东西)放弃。如果你坚持尝试，坚持写习题，坚持尝试弄懂习题的话，你最终一定会明白里边的内容的。</p>

<p>如果你通读了这部教程，却还是不知道编程是怎么回事。那也没关系，至少你尝试过了。你可以说你已经尽过力但成效不佳，但至少你尝试过了。这也是一件值得你骄傲的事情。</p>

<h2>许可协议</h2>

<p>你可以在不收取任何费用，而且不修改任何内容的前提下自由分发这本书给任何人。但是本书的内容只允许完整原封不动地进行分发和传播。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2011/11/16/di-2zhang-shui-shi-shui-de-ba-ba/">第2章:谁是谁的爸爸</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/15/di-1zhang-pei-zhi-kai-fa-huan-jing/">第1章:配置开发环境</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/15/di-0zhang-wei-shi-yao-yao-xue-xi-prolog/">第0章:为什么要学习Prolog</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/15/qian-yan/">前言</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - 泰安小码农 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
